image:
  # registry where weaviate image is stored
  registry: cr.weaviate.io
  tag: 1.27.8
  repo: semitechnologies/weaviate
  pullPolicy: IfNotPresent
  pullSecrets: []

# overwrite command and args if you want to run specific startup scripts, for
# example setting the nofile limit
command: ["/bin/weaviate"]
args:
  - '--host'
  - '0.0.0.0'
  - '--port'
  - '8080'
  - '--scheme'
  - 'http'
  - '--config-file'
  - '/weaviate-config/conf.yaml'
  - --read-timeout=60s
  - --write-timeout=60s

initContainers:
  sysctlInitContainer:
    enabled: true
    sysctlVmMaxMapCount: 524288
    image:
      registry: docker.io
      repo: alpine
      tag: latest
      pullPolicy: IfNotPresent
  ensureFileOwnershipContainer:
    enabled: false

replicas: 1

podManagementPolicy: Parallel
updateStrategy:
  type: RollingUpdate
resources:
  requests:
    cpu: '500m'
    memory: '300Mi'
  limits:
    cpu: '1000m'
    memory: '1Gi'

securityContext: {}

containerSecurityContext: {}

clusterDomain: cluster.local.

storage:
  size: 32Gi
  storageClassName: ""

service:
  name: weaviate
  ports:
    - name: http
      protocol: TCP
      port: 80
  type: LoadBalancer
  loadBalancerSourceRanges: []
  clusterIP:
  annotations: {}

grpcService:
  enabled: true
  name: weaviate-grpc
  ports:
    - name: grpc
      protocol: TCP
      port: 50051
  type: LoadBalancer
  loadBalancerSourceRanges: []
  clusterIP:
  annotations: {}

serviceMonitor:
  enabled: true
  interval: 30s
  scrapeTimeout: 10s

livenessProbe:
  probeType: httpGet
  probe:
    httpGet:
      path: /v1/.well-known/live
      port: 8080
  initialDelaySeconds: 900
  periodSeconds: 10
  failureThreshold: 30
  successThreshold: 1
  timeoutSeconds: 3

readinessProbe:
  probeType: httpGet
  probe:
    httpGet:
      path: /v1/.well-known/ready
      port: 8080
  initialDelaySeconds: 3
  periodSeconds: 10
  failureThreshold: 3
  successThreshold: 1
  timeoutSeconds: 3


terminationGracePeriodSeconds: 600

# Weaviate Config
#
# The following settings allow you to customize Weaviate to your needs, for
# example set authentication and authorization options. See weaviate docs
# (https://www.weaviate.io/developers/weaviate/) for all
# configuration.
authentication:
  enabled: true
  apikey:
    enabled: true
    allowed_keys:
      - admin
      - app
    users:
      - admin
      - app
  oidc:
    enabled: false
    # issuer: ''
    # username_claim: ''
    # groups_claim: ''
    # client_id: ''

authorization:
  anonymous_access: false
  rbac:
    enabled: true
    # admins:
    # - admin_user1
    # - admin_user2
    # viewers:
    # - viewer_user1
    # - readonly_user1
  admin_list:
    enabled: true
    users:
    - admin
    read_only_users: []

query_defaults:
  limit: 100
debug: false


# Insert any custom environment variables or envSecrets by putting the exact name
# and desired value into the settings below. Any env name passed will be automatically
# set for the statefulSet.
env:
  CLUSTER_GOSSIP_BIND_PORT: 7000
  CLUSTER_DATA_BIND_PORT: 7001

  # Set RAFT cluster expected number of voter nodes at bootstrap.
  # By default helm automatically sets this value based on the cluster size.
  # RAFT_BOOTSTRAP_EXPECT: 1

  # Set RAFT cluster bootstrap timeout (in seconds), default is 600 (seconds)
  # which should be sufficient for most of the deployments.
  RAFT_BOOTSTRAP_TIMEOUT: 600

  # Set manually RAFT voter nodes.
  # RAFT_JOIN value is automatically generated by "raft_configuration"
  # template, but if someone wants to set this value manually then it can be done
  # by setting RAFT_JOIN environment variable, example: RAFT_JOIN: "weaviate-0,weaviate-1"
  # Please notice that in this case RAFT_BOOTSTRAP_EXPECT setting needs to be also adjusted manually
  # to match the number of RAFT voters, so if there are 2 nodes set using RAFT_JOIN variable
  # then RAFT_BOOTSTRAP_EXPECT needs to be equal 2 also.
  # RAFT_JOIN: "weaviate-0"

  # Set to true if voters nodes should handle only schema. With this setting enabled
  # voter nodes will not accept any data, one needs to resize the cluster using replicas
  # setting so that replicas > voters.
  # RAFT_METADATA_ONLY_VOTERS: false

  # RAFT_ENABLE_FQDN_RESOLVER setting changes the node name to node ip resolution to use DNS lookups
  # instead of memberlist lookup. That means that when weaviate raft component wants to contact `weaviate-0`
  # it's going to lookup the dns name `weaviate-0` instead of looking for the node-id in memberlist.
  # This is particularly useful if running in an environment where you're using services (for example k8s)
  # where the IP of the services is different from the actual node IP, but it proxies the connection to the node.
  # RAFT_ENABLE_FQDN_RESOLVER: false

  # RAFT_FQDN_RESOLVER_TLD setting acts in combination with RAFT_ENABLE_FQDN_RESOLVER and is appended
  # in the format "[node-id].[tld]" when resolving a node-id to an ip.
  # RAFT_FQDN_RESOLVER_TLD: "weaviate-0."

  # The aggressiveness of the Go Garbage Collector. 100 is the default value.
  GOGC: 100

  # Expose metrics on port 2112 for Prometheus to scrape
  PROMETHEUS_MONITORING_ENABLED: false
  PROMETHEUS_MONITORING_GROUP: false

  # Set a MEM limit for the Weaviate Pod so it can help you both increase GC-related
  # performance as well as avoid GC-related out-of-memory (“OOM”) situations
  # GOMEMLIMIT: 6GiB

  # Maximum results Weaviate can query with/without pagination
  # NOTE: Affects performance, do NOT set to a very high value.
  # The default is 100K
  QUERY_MAXIMUM_RESULTS: 100000

  # whether to enable vector dimensions tracking metric
  TRACK_VECTOR_DIMENSIONS: false

  # whether to re-index/-compute the vector dimensions metric (needed if upgrading from weaviate < v1.16.0)
  REINDEX_VECTOR_DIMENSIONS_AT_STARTUP: false

  ##########################
  # API Keys with ENV Vars #
  ##########################
  # If using ENV Vars to set up API Keys make sure to have `authentication.apikey` block commented out
  # to avoid any future changes. ENV Vars has priority over the config above `authentication.apikey`.
  # If using `authentication.apikey `the below ENV Vars will be used because they have priority,
  # so comment them out to avoid any future changes. The same applies for the RBAC configuration
  # under the authorization block.
  # Enables API key authentication. If it is set to 'false' the AUTHENTICATION_APIKEY_ALLOWED_KEYS
  # and AUTHENTICATION_APIKEY_USERS will not have any effect.
  # AUTHENTICATION_APIKEY_ENABLED: 'true'

  # List one or more keys, separated by commas. Each key corresponds to a specific user identity below.
  # If you want to use a kubernetes secret for the API Keys comment out this Variable and use the one in `envSecrets` below
  # AUTHENTICATION_APIKEY_ALLOWED_KEYS: 'jane-secret-key,ian-secret-key'  (plain text)

  # List one or more user identities, separated by commas. You can have only one User for all the keys or one user per key.
  # The User/s can be a simple name or an email, no matter if it exists or not.
  # NOTE: Make sure to add the users to the authorization above overwise they will not be allowed to interact with Weaviate.
  # AUTHENTICATION_APIKEY_USERS: 'jane@doe.com,ian-smith'

  # Enabling RBAC authorization. It is mutually exclusive with the AUTHORIZATION_ADMIN_LISTS variable. Either RBAC or the
  # admin lists mechanism can be used.
  # AUTHORIZATION_ENABLE_RBAC: "true"

  # Users with admin's RBAC role. List one or more user identities, separated by commas, which will
  # have the admin role assigned to. This role provides all permissions to the user, but it's required at least
  # in one of the user for managing the cluster.
  # AUTHORIZATION_ADMIN_USERS: "admin-user"

  # Users with viewer's RBAC role. List one or more user identities, separated by commas, which will
  # have the viewer role assigned to. This role allows read permissions in all different areas. Once assigned via
  # config, it can't be revoked via API AuthZ calls.
  # AUTHORIZATION_VIEWER_USERS: "viewer-user"


envSecrets:
  # create a Kubernetes secret with AUTHENTICATION_APIKEY_ALLOWED_KEYS key and its respective value
  # AUTHENTICATION_APIKEY_ALLOWED_KEYS: name-of-the-k8s-secret-containing-the-comma-separated-api-keys

# Configure offload providers
offload:
  s3:
    enabled: false
# Configure backup providers
backups:
  # The backup-filesystem module enables creation of the DB backups in
  # the local filesystem
  filesystem:
    enabled: false
    envconfig:
      # Configure folder where backups should be saved
      BACKUP_FILESYSTEM_PATH: /tmp/backups

# modules are extensions to Weaviate, they can be used to support various
# ML-models, but also other features unrelated to model inference.
# An inference/vectorizer module is not required, you can also run without any
# modules and import your own vectors.
modules:
  # The text2vec-openai module uses OpenAI Embeddings API
  # to dynamically compute vector embeddings based on the
  # sentence's context.
  # More information about OpenAI Embeddings API can be found here:
  # https://beta.openai.com/docs/guides/embeddings/what-are-embeddings
  text2vec-openai:
    # enable if you want to use OpenAI module
    enabled: true

  # The ref2vec-centroid module
  ref2vec-centroid:

    # enable if you want to use Centroid module
    enabled: true

  # The text2vec-ollama module uses Ollama Embeddings API
  # to dynamically compute vector embeddings based on the
  # sentence's context.
  # More information about Ollama Embeddings API can be found here:
  # https://github.com/ollama/ollama/blob/main/docs/api.md#generate-embeddings
  # Please note that you have to deploy Ollama container by yourself
  # and then properly point the Ollama endpoint using module settings.
  # More about this configuration can be found here:
  # https://weaviate.io/developers/weaviate/modules/retriever-vectorizer-modules/text2vec-ollama#ollama-endpoint
  text2vec-ollama:

    # enable if you want to use Ollama module
    enabled: true

  # The multi2vec-clip modules uses CLIP transformers to vectorize both images
  # and text in the same vector space. It is typically slow(er) on CPUs and should
  # run with CUDA-enabled GPUs for optimal performance.
  multi2vec-clip:

    # Enable deployment of this module
    enabled: false

    # You can set directly an inference URL of this module without deploying it with this release.
    # You can do so by setting a value for the `inferenceUrl` here AND by setting the `enable` to `false`
    inferenceUrl: {}

    # The configuration below is ignored if enabled==false

    # replace with model of choice, see
    # https://weaviate.io/developers/weaviate/modules/retriever-vectorizer-modules/multi2vec-clip
    # for all supported models or build your own container.
    tag: sentence-transformers-clip-ViT-B-32-multilingual-v1
    repo: semitechnologies/multi2vec-clip
    registry: cr.weaviate.io
    replicas: 1
    strategy:
      type: RollingUpdate
    imagePullPolicy: IfNotPresent
    imagePullSecrets: []
    priorityClassName: ""
    fullnameOverride: clip-inference
    livenessProbe:
      initialDelaySeconds: 120
      periodSeconds: 3
      timeoutSeconds: 3
    readinessProbe:
      initialDelaySeconds: 120
      periodSeconds: 3
    envconfig:
      # enable for CUDA support. Your K8s cluster needs to be configured
      # accordingly and you need to explicitly set GPU requests & limits below
      enable_cuda: false

      # only used when CUDA is enabled
      nvidia_visible_devices: all
      nvidia_driver_capabilities: compute,utility

      # only used when CUDA is enabled
      ld_library_path: /usr/local/nvidia/lib64

    resources: {}
      # requests:
      #   cpu: '1000m'
      #   memory: '3000Mi'
      #   enable if running with CUDA support
      #   nvidia.com/gpu: 1
      # limits:
      #   cpu: '1000m'
      #   memory: '5000Mi'
      #   enable if running with CUDA support
      #   nvidia.com/gpu: 1

    # security Context for the Contextionary Pods. The configurations are the same as setting them
    # as described here: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
    securityContext: {}

    # It is possible to add a ServiceAccount to this module's Pods, it can be
    # used in cases where the module is in a private registry and you want to
    # give access to the registry only to this pod.
    # NOTE: if not set the root `serviceAccountName` config will be used.
    serviceAccountName:

    annotations:
    nodeSelector:
    tolerations:

# custom configmap The authorization and authentication values defined in
# values.yaml will be ignored when defining a custom config map.
custom_config_map:
  enabled: false
  name: 'custom-config'

# Pass any annotations to Weaviate pods
annotations:

extraVolumeMounts:

extraVolumes:

nodeSelector:

tolerations:

hostAliases:

affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 1
        podAffinityTerm:
          topologyKey: "kubernetes.io/hostname"
          labelSelector:
            matchExpressions:
              - key: "app"
                operator: In
                values:
                  - weaviate

## Optionally specify priorityClass name for the pod
## ref: https://kubernetes.io/docs/concepts/scheduling-eviction/pod-priority-preemption/#pod-priority
##
priorityClassName: ""
globalPriorityClassName: ""

